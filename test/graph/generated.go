// Code generated by goinmonster. DO NOT EDIT.
// Source: goinmonster generate

package graph

import (
	"context"
	"fmt"
	"time"

	"github.com/eddieafk/goinmonster/graph"
	"github.com/eddieafk/goinmonster/graph/marshal"
	"github.com/eddieafk/goinmonster/sql/ast"
	"github.com/eddieafk/goinmonster/sql/dialect"
)

// SQLConverter provides the configured SQL converter
var sqlConverter *graph.SQLConverter

// InitSQLConverter initializes the SQL converter with schema mappings
func InitSQLConverter(schema *graph.Schema) *graph.SQLConverter {
	sqlConverter = graph.NewSQLConverter(schema, dialect.PostgreSQL)

	sqlConverter.MapTypeToTable("User", "users")



	return sqlConverter
}

// RegisterMarshalers registers custom scalar marshalers on the schema
func RegisterMarshalers(schema *graph.Schema) {
	schema.RegisterScalar("DateTime", &DateTimeMarshaler{})
	schema.RegisterScalar("ID", &IDMarshaler{})
	schema.RegisterScalar("JSON", &JSONMarshaler{})
}


// DateTimeMarshaler handles DateTime scalar marshaling
type DateTimeMarshaler struct{}

func (m *DateTimeMarshaler) MarshalGraphQL(v interface{}) (interface{}, error) {
	switch t := v.(type) {
	case time.Time:
		return t.Format(time.RFC3339), nil
	case *time.Time:
		if t == nil {
			return nil, nil
		}
		return t.Format(time.RFC3339), nil
	}
	return nil, fmt.Errorf("cannot marshal %T as DateTime", v)
}

func (m *DateTimeMarshaler) UnmarshalGraphQL(v interface{}) (interface{}, error) {
	return marshal.UnmarshalTime(v)
}

// IDMarshaler handles ID scalar marshaling
type IDMarshaler struct{}

func (m *IDMarshaler) MarshalGraphQL(v interface{}) (interface{}, error) {
	return v, nil
}

func (m *IDMarshaler) UnmarshalGraphQL(v interface{}) (interface{}, error) {
	return v, nil
}

// JSONMarshaler handles JSON scalar marshaling
type JSONMarshaler struct{}

func (m *JSONMarshaler) MarshalGraphQL(v interface{}) (interface{}, error) {
	return v, nil
}

func (m *JSONMarshaler) UnmarshalGraphQL(v interface{}) (interface{}, error) {
	return marshal.UnmarshalJSON(v)
}

// RegisterResolvers registers all resolvers on the executable schema
func RegisterResolvers(es *graph.ExecutableSchema, resolver ResolverRoot) {
	es.RegisterResolver("Query", "users", resolver.Query().Users(es))
	es.RegisterResolver("Query", "user", resolver.Query().User(es))
	es.RegisterResolver("Query", "__schema", resolver.Query().__schema(es))
	es.RegisterResolver("Query", "__type", resolver.Query().__type(es))
	es.RegisterResolver("Mutation", "createUser", resolver.Mutation().CreateUser(es))
	es.RegisterResolver("Mutation", "updateUser", resolver.Mutation().UpdateUser(es))
	es.RegisterResolver("Mutation", "deleteUser", resolver.Mutation().DeleteUser(es))
}

// ResolverRoot is the root resolver interface
type ResolverRoot interface {
	Query() QueryResolver
	Mutation() MutationResolver
}

// QueryResolver contains all query resolvers
type QueryResolver interface {
	Users(es *graph.ExecutableSchema) graph.ResolverFunc
	User(es *graph.ExecutableSchema) graph.ResolverFunc
	__schema(es *graph.ExecutableSchema) graph.ResolverFunc
	__type(es *graph.ExecutableSchema) graph.ResolverFunc
}

// MutationResolver contains all mutation resolvers
type MutationResolver interface {
	CreateUser(es *graph.ExecutableSchema) graph.ResolverFunc
	UpdateUser(es *graph.ExecutableSchema) graph.ResolverFunc
	DeleteUser(es *graph.ExecutableSchema) graph.ResolverFunc
}

// Ensure variables are used
var (
	_ = context.Background
	_ = fmt.Sprintf
	_ = time.Now
	_ = ast.JoinInner
	_ = dialect.PostgreSQL
	_ = marshal.MarshalString
)
