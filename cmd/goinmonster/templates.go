package goinmonster

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"
)

// Templates for code generation

const generatedFileTemplate = `// Code generated by goinmonster. DO NOT EDIT.
// Source: goinmonster generate

package {{.Package}}

import (
	"context"
	"fmt"
	"time"

	"github.com/eddieafk/goinmonster/graph"
	"github.com/eddieafk/goinmonster/graph/marshal"
	"github.com/eddieafk/goinmonster/sql/ast"
	"github.com/eddieafk/goinmonster/sql/dialect"
)

// SQLConverter provides the configured SQL converter
var sqlConverter *graph.SQLConverter

// InitSQLConverter initializes the SQL converter with schema mappings
func InitSQLConverter(schema *graph.Schema) *graph.SQLConverter {
	sqlConverter = graph.NewSQLConverter(schema, {{.DialectVar}})
{{range .TableMappings}}
	sqlConverter.MapTypeToTable("{{.TypeName}}", "{{.TableName}}")
{{- end}}
{{range .FieldMappings}}
	sqlConverter.MapFieldToColumn("{{.TypeName}}", "{{.FieldName}}", "{{.ColumnName}}")
{{- end}}
{{range .JoinConfigs}}
	sqlConverter.ConfigureJoin("{{.TypeName}}", "{{.FieldName}}", &graph.JoinConfig{
		SourceTable:  "{{.SourceTable}}",
		SourceColumn: "{{.SourceColumn}}",
		TargetTable:  "{{.TargetTable}}",
		TargetColumn: "{{.TargetColumn}}",
		JoinType:     {{.JoinType}},
		RelationType: "{{.RelationType}}",
	})
{{- end}}

	return sqlConverter
}

// RegisterMarshalers registers custom scalar marshalers on the schema
func RegisterMarshalers(schema *graph.Schema) {
{{- range .Scalars}}
	schema.RegisterScalar("{{.Name}}", &{{.Marshaler}}{})
{{- end}}
}
{{range .Scalars}}

// {{.Marshaler}} handles {{.Name}} scalar marshaling
type {{.Marshaler}} struct{}

func (m *{{.Marshaler}}) MarshalGraphQL(v interface{}) (interface{}, error) {
{{- if eq .Name "DateTime"}}
	switch t := v.(type) {
	case time.Time:
		return t.Format(time.RFC3339), nil
	case *time.Time:
		if t == nil {
			return nil, nil
		}
		return t.Format(time.RFC3339), nil
	}
	return nil, fmt.Errorf("cannot marshal %T as DateTime", v)
{{- else if eq .Name "JSON"}}
	return v, nil
{{- else}}
	return v, nil
{{- end}}
}

func (m *{{.Marshaler}}) UnmarshalGraphQL(v interface{}) (interface{}, error) {
{{- if eq .Name "DateTime"}}
	return marshal.UnmarshalTime(v)
{{- else if eq .Name "JSON"}}
	return marshal.UnmarshalJSON(v)
{{- else}}
	return v, nil
{{- end}}
}
{{- end}}

// RegisterResolvers registers all resolvers on the executable schema
func RegisterResolvers(es *graph.ExecutableSchema, resolver ResolverRoot) {
{{- range .QueryFields}}
	es.RegisterResolver("Query", "{{.Name}}", resolver.Query().{{.GoName}}(es))
{{- end}}
{{- range .MutationFields}}
	es.RegisterResolver("Mutation", "{{.Name}}", resolver.Mutation().{{.GoName}}(es))
{{- end}}
}

// ResolverRoot is the root resolver interface
type ResolverRoot interface {
	Query() QueryResolver
	Mutation() MutationResolver
}

// QueryResolver contains all query resolvers
type QueryResolver interface {
{{- range .QueryFields}}
	{{.GoName}}(es *graph.ExecutableSchema) graph.ResolverFunc
{{- end}}
}

// MutationResolver contains all mutation resolvers
type MutationResolver interface {
{{- range .MutationFields}}
	{{.GoName}}(es *graph.ExecutableSchema) graph.ResolverFunc
{{- end}}
}

// Ensure variables are used
var (
	_ = context.Background
	_ = fmt.Sprintf
	_ = time.Now
	_ = ast.JoinInner
	_ = dialect.PostgreSQL
	_ = marshal.MarshalString
)
`

const resolversFileTemplate = `package {{.Package}}

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/eddieafk/goinmonster/graph"
)

// Resolver is the root resolver
type Resolver struct {
	// Add your dependencies here (e.g., database connection)
}

// Query returns the query resolver
func (r *Resolver) Query() QueryResolver {
	return &queryResolver{r}
}

// Mutation returns the mutation resolver
func (r *Resolver) Mutation() MutationResolver {
	return &mutationResolver{r}
}

type queryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
{{range .QueryFields}}

// {{.GoName}} resolves Query.{{.Name}}
func (r *queryResolver) {{.GoName}}(es *graph.ExecutableSchema) graph.ResolverFunc {
	return func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		info := graph.GetResolveInfo(ctx)
		if info == nil {
			return nil, fmt.Errorf("missing resolve info")
		}

		// Convert to SQL query
		result, err := sqlConverter.ConvertToSelect(ctx, info)
		if err != nil {
			return nil, err
		}

		log.Printf("Generated SQL: %s", result.Query)
		log.Printf("Parameters: %v", result.Params)

		// TODO: Execute query against your database
		// rows, err := db.QueryContext(ctx, result.Query, result.Params...)
{{if .IsList}}
		// Return mock data for now
		return []map[string]interface{}{}, nil
{{else}}
		// Return mock data for now
		return map[string]interface{}{}, nil
{{end}}
	}
}
{{- end}}
{{range .MutationFields}}

// {{.GoName}} resolves Mutation.{{.Name}}
func (r *mutationResolver) {{.GoName}}(es *graph.ExecutableSchema) graph.ResolverFunc {
	return func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
{{- if .HasInput}}
		input, ok := args["input"].(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("input is required")
		}
{{end}}
{{- if .HasID}}
		id, ok := args["id"].(string)
		if !ok {
			return nil, fmt.Errorf("id is required")
		}
{{end}}
		info := graph.GetResolveInfo(ctx)
		returning := []string{"id"}
		if info != nil && info.Selection != nil {
			returning = graph.GetFieldNames(info.Selection)
		}
{{if eq .MutationType "create"}}
		result, err := sqlConverter.ConvertToInsert(ctx, "{{.TypeName}}", input, returning)
		if err != nil {
			return nil, err
		}
{{else if eq .MutationType "update"}}
		where := map[string]interface{}{"id": id}
		result, err := sqlConverter.ConvertToUpdate(ctx, "{{.TypeName}}", where, input, returning)
		if err != nil {
			return nil, err
		}
{{else if eq .MutationType "delete"}}
		where := map[string]interface{}{"id": id}
		result, err := sqlConverter.ConvertToDelete(ctx, "{{.TypeName}}", where, returning)
		if err != nil {
			return nil, err
		}
{{else}}
		_ = returning
		var result struct{ Query string; Params []interface{} }
{{end}}
		log.Printf("Generated SQL: %s", result.Query)
		log.Printf("Parameters: %v", result.Params)

		// TODO: Execute mutation against your database
{{if eq .MutationType "delete"}}
		return true, nil
{{else}}
		return map[string]interface{}{}, nil
{{end}}
	}
}
{{- end}}

// Ensure imports are used
var (
	_ = time.Now
	_ = log.Printf
)
`

const serverFileTemplate = `package main

import (
	"log"
	"net/http"
	"time"
	"context"

	"{{.ModulePath}}/{{.Package}}"
	gqlgraph "github.com/eddieafk/goinmonster/graph"
	"github.com/eddieafk/goinmonster/handler"
)

func main() {
	// Load schema from embedded string or file
	schemaString := ` + "`" + `{{.SchemaContent}}` + "`" + `

	// Create the executable schema
	es, err := gqlgraph.NewExecutableSchema(schemaString)
	if err != nil {
		log.Fatalf("Failed to create schema: %v", err)
	}

	// Initialize SQL converter with mappings
	{{.Package}}.InitSQLConverter(es.Schema)

	// Register custom scalar marshalers
	{{.Package}}.RegisterMarshalers(es.Schema)

	// Register resolvers
	resolver := &{{.Package}}.Resolver{
		// TODO: Add your dependencies here (e.g., database connection)
	}
	{{.Package}}.RegisterResolvers(es, resolver)

	// Create the HTTP server
	srv := handler.New(es)

	// Add transports
	srv.AddTransport(handler.NewOPTIONS())
	srv.AddTransport(handler.NewGET())
	srv.AddTransport(handler.NewPOST())
	srv.AddTransport(handler.NewMultipartForm())

	// Add extensions
	srv.Use(handler.NewTracing())
	srv.Use(handler.NewComplexityLimit(1000))
	srv.Use(handler.NewRequestLogger(func(ctx context.Context, query, opName string, vars map[string]interface{}, duration time.Duration) {
		log.Printf("[GraphQL] %s (%s) took %v", opName, truncateQuery(query), duration)
	}))
	srv.Use(handler.NewErrorLogger(func(ctx context.Context, err *gqlgraph.Error) {
		log.Printf("[GraphQL Error] %s", err.Message)
	}))

	// Set up HTTP handler with CORS
	mux := http.NewServeMux()
	mux.Handle("/graphql", corsMiddleware(srv))
	mux.Handle("/playground", corsMiddleware(srv))

	// Start server
	addr := ":8080"
	log.Printf("ðŸš€ GraphQL server running at http://localhost%s/graphql", addr)
	log.Printf("ðŸŽ® Playground available at http://localhost%s/playground", addr)

	if err := http.ListenAndServe(addr, mux); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}

// corsMiddleware adds CORS headers
func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

// truncateQuery truncates a query for logging
func truncateQuery(query string) string {
	if len(query) > 100 {
		return query[:100] + "..."
	}
	return query
}
`

type GeneratedData struct {
	Package        string
	ModulePath     string
	SchemaContent  string
	DialectVar     string
	TableMappings  []TableMapping
	FieldMappings  []FieldMapping
	JoinConfigs    []JoinConfigData
	Scalars        []ScalarData
	QueryFields    []FieldData
	MutationFields []MutationFieldData
}

type TableMapping struct {
	TypeName  string
	TableName string
}

type FieldMapping struct {
	TypeName   string
	FieldName  string
	ColumnName string
}

type JoinConfigData struct {
	TypeName     string
	FieldName    string
	SourceTable  string
	SourceColumn string
	TargetTable  string
	TargetColumn string
	JoinType     string
	RelationType string
}

type ScalarData struct {
	Name      string
	GoType    string
	Marshaler string
}

type FieldData struct {
	Name   string
	GoName string
	IsList bool
}

type MutationFieldData struct {
	Name         string
	GoName       string
	TypeName     string
	MutationType string // create, update, delete
	HasInput     bool
	HasID        bool
}

func generateCode(path string, config *Config, analysis *SchemaAnalysis) error {
	data := prepareGeneratedData(config, analysis)

	tmpl, err := template.New("generated").Parse(generatedFileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return os.WriteFile(path, buf.Bytes(), 0644)
}

func generateResolvers(path string, config *Config, analysis *SchemaAnalysis) error {
	data := prepareGeneratedData(config, analysis)

	tmpl, err := template.New("resolvers").Parse(resolversFileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return os.WriteFile(path, buf.Bytes(), 0644)
}

func prepareGeneratedData(config *Config, analysis *SchemaAnalysis) *GeneratedData {
	data := &GeneratedData{
		Package: config.Output.Package,
	}

	// Set dialect
	switch strings.ToLower(config.Database.Dialect) {
	case "postgresql", "postgres":
		data.DialectVar = "dialect.PostgreSQL"
	case "mysql":
		data.DialectVar = "dialect.MySQL"
	case "sqlite":
		data.DialectVar = "dialect.SQLite"
	default:
		data.DialectVar = "dialect.PostgreSQL"
	}

	// Table mappings from config
	for typeName, tableName := range config.Models {
		data.TableMappings = append(data.TableMappings, TableMapping{
			TypeName:  typeName,
			TableName: tableName,
		})
	}

	// Auto-generate table mappings for types not in config
	for _, typeDef := range analysis.ObjectTypes {
		if typeDef.Name == "Query" || typeDef.Name == "Mutation" || typeDef.Name == "Subscription" {
			continue
		}
		if _, exists := config.Models[typeDef.Name]; !exists {
			data.TableMappings = append(data.TableMappings, TableMapping{
				TypeName:  typeDef.Name,
				TableName: toSnakeCase(typeDef.Name) + "s",
			})
		}
	}

	// Sort for consistent output
	sort.Slice(data.TableMappings, func(i, j int) bool {
		return data.TableMappings[i].TypeName < data.TableMappings[j].TypeName
	})

	// Field mappings from config
	for key, columnName := range config.Fields {
		parts := strings.SplitN(key, ".", 2)
		if len(parts) == 2 {
			data.FieldMappings = append(data.FieldMappings, FieldMapping{
				TypeName:   parts[0],
				FieldName:  parts[1],
				ColumnName: columnName,
			})
		}
	}

	// Auto-detect camelCase fields that need snake_case mapping
	for _, typeDef := range analysis.ObjectTypes {
		if typeDef.Name == "Query" || typeDef.Name == "Mutation" || typeDef.Name == "Subscription" {
			continue
		}
		for _, field := range typeDef.Fields {
			key := typeDef.Name + "." + field.Name
			if _, exists := config.Fields[key]; !exists {
				snakeName := toSnakeCase(field.Name)
				if snakeName != field.Name && containsUpperCase(field.Name) {
					data.FieldMappings = append(data.FieldMappings, FieldMapping{
						TypeName:   typeDef.Name,
						FieldName:  field.Name,
						ColumnName: snakeName,
					})
				}
			}
		}
	}

	// Sort for consistent output
	sort.Slice(data.FieldMappings, func(i, j int) bool {
		if data.FieldMappings[i].TypeName == data.FieldMappings[j].TypeName {
			return data.FieldMappings[i].FieldName < data.FieldMappings[j].FieldName
		}
		return data.FieldMappings[i].TypeName < data.FieldMappings[j].TypeName
	})

	// Join configs from relations
	for key, rel := range config.Relations {
		parts := strings.SplitN(key, ".", 2)
		if len(parts) == 2 {
			joinType := "ast.JoinLeft"
			switch strings.ToLower(rel.JoinType) {
			case "inner":
				joinType = "ast.JoinInner"
			case "right":
				joinType = "ast.JoinRight"
			case "left":
				joinType = "ast.JoinLeft"
			}

			sourceTable := getTableName(parts[0], config.Models, data.TableMappings)
			targetTable := rel.Table
			if targetTable == "" {
				targetTable = getTableName(parts[1], config.Models, data.TableMappings)
			}

			data.JoinConfigs = append(data.JoinConfigs, JoinConfigData{
				TypeName:     parts[0],
				FieldName:    parts[1],
				SourceTable:  sourceTable,
				SourceColumn: rel.References,
				TargetTable:  targetTable,
				TargetColumn: rel.ForeignKey,
				JoinType:     joinType,
				RelationType: rel.Type,
			})
		}
	}

	// Analyze relations from schema @sql directives
	for _, typeDef := range analysis.ObjectTypes {
		if typeDef.Name == "Query" || typeDef.Name == "Mutation" || typeDef.Name == "Subscription" {
			continue
		}
		for _, field := range typeDef.Fields {
			if field.Relation != "" {
				key := typeDef.Name + "." + field.Name
				if _, exists := config.Relations[key]; !exists {
					sourceTable := getTableName(typeDef.Name, config.Models, data.TableMappings)
					targetTable := getTableName(field.TypeName, config.Models, data.TableMappings)

					joinType := "ast.JoinLeft"
					foreignKey := "id"
					references := toSnakeCase(field.TypeName) + "_id"

					switch field.Relation {
					case "hasMany":
						foreignKey = toSnakeCase(typeDef.Name) + "_id"
						references = "id"
					case "belongsTo":
						joinType = "ast.JoinInner"
						foreignKey = "id"
						references = toSnakeCase(field.TypeName) + "_id"
					case "hasOne":
						foreignKey = toSnakeCase(typeDef.Name) + "_id"
						references = "id"
					}

					data.JoinConfigs = append(data.JoinConfigs, JoinConfigData{
						TypeName:     typeDef.Name,
						FieldName:    field.Name,
						SourceTable:  sourceTable,
						SourceColumn: references,
						TargetTable:  targetTable,
						TargetColumn: foreignKey,
						JoinType:     joinType,
						RelationType: field.Relation,
					})
				}
			}
		}
	}

	// Scalar marshalers
	for name, scalar := range config.Scalars {
		marshaler := scalar.Marshaler
		if marshaler == "" {
			marshaler = name + "Marshaler"
		}
		data.Scalars = append(data.Scalars, ScalarData{
			Name:      name,
			GoType:    scalar.GoType,
			Marshaler: marshaler,
		})
	}

	// Also add scalars found in schema but not in config
	for _, scalar := range analysis.Scalars {
		found := false
		for _, s := range data.Scalars {
			if s.Name == scalar {
				found = true
				break
			}
		}
		if !found {
			data.Scalars = append(data.Scalars, ScalarData{
				Name:      scalar,
				GoType:    "interface{}",
				Marshaler: scalar + "Marshaler",
			})
		}
	}

	// Sort scalars
	sort.Slice(data.Scalars, func(i, j int) bool {
		return data.Scalars[i].Name < data.Scalars[j].Name
	})

	// Query fields
	for _, field := range analysis.QueryFields {
		data.QueryFields = append(data.QueryFields, FieldData{
			Name:   field.Name,
			GoName: toExportedName(field.Name),
			IsList: field.IsList,
		})
	}

	// Mutation fields
	for _, field := range analysis.MutationFields {
		mutationType := "unknown"
		typeName := field.TypeName

		lowerName := strings.ToLower(field.Name)
		if strings.HasPrefix(lowerName, "create") {
			mutationType = "create"
			typeName = strings.TrimPrefix(field.Name, "create")
			typeName = strings.TrimPrefix(typeName, "Create")
		} else if strings.HasPrefix(lowerName, "update") {
			mutationType = "update"
			typeName = strings.TrimPrefix(field.Name, "update")
			typeName = strings.TrimPrefix(typeName, "Update")
		} else if strings.HasPrefix(lowerName, "delete") {
			mutationType = "delete"
			typeName = strings.TrimPrefix(field.Name, "delete")
			typeName = strings.TrimPrefix(typeName, "Delete")
		}

		hasInput := false
		hasID := false
		for _, arg := range field.Arguments {
			if arg == "input" {
				hasInput = true
			}
			if arg == "id" {
				hasID = true
			}
		}

		data.MutationFields = append(data.MutationFields, MutationFieldData{
			Name:         field.Name,
			GoName:       toExportedName(field.Name),
			TypeName:     typeName,
			MutationType: mutationType,
			HasInput:     hasInput,
			HasID:        hasID,
		})
	}

	return data
}

func getTableName(typeName string, models map[string]string, mappings []TableMapping) string {
	if table, ok := models[typeName]; ok {
		return table
	}
	for _, m := range mappings {
		if m.TypeName == typeName {
			return m.TableName
		}
	}
	return toSnakeCase(typeName) + "s"
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func toExportedName(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func containsUpperCase(s string) bool {
	for _, r := range s {
		if r >= 'A' && r <= 'Z' {
			return true
		}
	}
	return false
}

func generateServer(path string, config *Config, analysis *SchemaAnalysis, schemaContent string) error {
	// Get module path from go.mod
	modulePath := getModulePath()

	// Escape backticks in schema content for embedding
	escapedSchema := strings.ReplaceAll(schemaContent, "`", "` + \"`\" + `")

	data := &ServerData{
		Package:       config.Output.Package,
		ModulePath:    modulePath,
		SchemaContent: escapedSchema,
	}

	tmpl, err := template.New("server").Parse(serverFileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return os.WriteFile(path, buf.Bytes(), 0644)
}

type ServerData struct {
	Package       string
	ModulePath    string
	SchemaContent string
}

func getModulePath() string {
	// Try to read go.mod
	data, err := os.ReadFile("go.mod")
	if err != nil {
		return "myproject"
	}

	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimPrefix(line, "module ")
		}
	}

	return "myproject"
}
